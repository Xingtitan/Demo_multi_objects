<!DOCTYPE html>
<html>

<head>
  <meta charset=UTF-8 />
  <link rel="stylesheet" href="./styles.css">
</head>

<body>
  <div id="left">
  </div>
  <div id="right">
  </div>

  <script type="module">

    import * as THREE from './build/three.module.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import Stats from './js/stats.module.js';

    let sceneFirst, cameraFirst, rendererFirst, controlsFirst;
    let sceneSecond, cameraSecond, rendererSecond, controlsSecond;

    function firstObject() {
      /* Create a scene with a camera and a render for the first element. */
      // Create scene and camera.
      sceneFirst = new THREE.Scene();
      cameraFirst = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      cameraFirst.position.set(0, 0, 200);
      cameraFirst.lookAt(0, 0, 0);

      // Create renderer.
      const containerFirst = document.getElementById("left");
      rendererFirst = new THREE.WebGLRenderer({ antialias: true });
      rendererFirst.setSize(window.innerWidth, window.innerHeight);
      containerFirst.appendChild(rendererFirst.domElement);

      controlsFirst = new OrbitControls(cameraFirst, rendererFirst.domElement);


      const geometryFirst = new THREE.SphereGeometry(50, 32, 32);
      const materialFirst = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        wireframe: true,
      });
      const sphereFirst = new THREE.Mesh(geometryFirst, materialFirst);
      sceneFirst.add(sphereFirst);

      const onResize = () => {
        rendererFirst.setSize(window.innerWidth, window.innerHeight);
        cameraFirst.aspect = window.innerWidth / window.innerHeight;
        cameraFirst.updateProjectionMatrix();
      };

      const animate = () => {
        requestAnimationFrame(animate);
        sphereFirst.rotation.y += 0.002;
        rendererFirst.render(sceneFirst, cameraFirst);
      };

      animate();
    };

    function secondObject() {
      /* Create a scene with a camera and a render for the first element. */
      // Create scene and camera.
      sceneSecond = new THREE.Scene();
      cameraSecond = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      cameraSecond.position.set(0, 0, 200);
      cameraSecond.lookAt(0, 0, 0);

      // Create renderer.
      const containerSecond = document.getElementById("right");
      rendererSecond = new THREE.WebGLRenderer({ antialias: true });
      rendererSecond.setSize(window.innerWidth, window.innerHeight);
      containerSecond.appendChild(rendererSecond.domElement);

      controlsSecond = new OrbitControls(cameraSecond, rendererSecond.domElement);


      const geometrySecond = new THREE.SphereGeometry(50, 32, 32);
      const materialSecond = new THREE.MeshBasicMaterial({
        color: 0xfff232,
        wireframe: true,
      });
      const sphereSecond = new THREE.Mesh(geometrySecond, materialSecond);
      sceneSecond.add(sphereSecond);

      const onResize = () => {
        rendererSecond.setSize(window.innerWidth, window.innerHeight);
        cameraSecond.aspect = window.innerWidth / window.innerHeight;
        cameraSecond.updateProjectionMatrix();
      };

      const animate = () => {
        requestAnimationFrame(animate);
        sphereSecond.rotation.y += 0.002;
        rendererSecond.render(sceneSecond, cameraSecond);
      };

      animate();
    };

    firstObject();
    secondObject();

  </script>
</body>

</html>